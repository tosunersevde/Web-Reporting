"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.MouseHandlerDragDiagramItemStateBase = exports.DraggingConnector = void 0;
var ModelUtils_1 = require("../../Model/ModelUtils");
var ModelOperationSettings_1 = require("../../ModelOperationSettings");
var Event_1 = require("../Event");
var MouseHandlerDraggingState_1 = require("./MouseHandlerDraggingState");
var DragHelper_1 = require("../../Model/Helpers/DragHelper");
var DraggingConnector = (function () {
    function DraggingConnector(connector) {
        this.connector = connector;
        this.startPoints = connector.points.map(function (x) { return x.clone(); });
        this.startRenderContext = connector.tryCreateRenderPointsContext();
    }
    return DraggingConnector;
}());
exports.DraggingConnector = DraggingConnector;
var MouseHandlerDragDiagramItemStateBase = (function (_super) {
    __extends(MouseHandlerDragDiagramItemStateBase, _super);
    function MouseHandlerDragDiagramItemStateBase(handler, history, model, selection, visualizerManager) {
        var _this = _super.call(this, handler, history) || this;
        _this.model = model;
        _this.selection = selection;
        _this.visualizerManager = visualizerManager;
        _this.startScrollLeft = 0;
        _this.startScrollTop = 0;
        return _this;
    }
    MouseHandlerDragDiagramItemStateBase.prototype.finish = function () {
        this.visualizerManager.resetExtensionLines();
        this.visualizerManager.resetContainerTarget();
        this.visualizerManager.resetConnectionTarget();
        this.visualizerManager.resetConnectionPoints();
        _super.prototype.finish.call(this);
    };
    MouseHandlerDragDiagramItemStateBase.prototype.onMouseDown = function (evt) {
        this.handler.addDiagramItemToSelection(evt);
        this.shouldClone = this.handler.canCopySelectedItems(evt);
        this.startPoint = evt.modelPoint;
        this.initDrag();
        this.lockInitDrag = false;
        _super.prototype.onMouseDown.call(this, evt);
    };
    MouseHandlerDragDiagramItemStateBase.prototype.onMouseMove = function (evt) {
        this.mouseMoveEvent = evt;
        if (evt.button !== Event_1.MouseButton.Left) {
            this.cancelChanges();
            this.handler.switchToDefaultState();
            return;
        }
        if (!this.canApplyChangesOnMouseMove(this.startPoint, evt.modelPoint))
            return;
        if (this.handler.canCopySelectedItems(evt))
            if (!this.lockInitDrag) {
                this.cancelChanges();
                this.shouldClone = true;
                this.copySelection();
                this.initDrag();
                this.lockInitDrag = true;
            }
        this.onApplyChanges(evt);
        this.onAfterApplyChanges();
        this.updateContainers(evt);
    };
    MouseHandlerDragDiagramItemStateBase.prototype.updateContainers = function (evt) {
        this.visualizerManager.setExtensionLines(this.selection.getSelectedShapes(false, true));
        var container = ModelUtils_1.ModelUtils.findContainerByEventKey(this.model, this.selection, evt.source.key);
        if (container && this.allowInsertToContainer(evt, container))
            this.visualizerManager.setContainerTarget(container, evt.source.type);
        else
            this.visualizerManager.resetContainerTarget();
    };
    MouseHandlerDragDiagramItemStateBase.prototype.onMouseUp = function (evt) {
        _super.prototype.onMouseUp.call(this, evt);
        if (this.handler.canRemoveDiagramItemToSelection(evt) && this.handler.canMultipleSelection(evt))
            this.handler.removeDiagramItemFromSelection(evt.button, evt.source.key);
    };
    MouseHandlerDragDiagramItemStateBase.prototype.onApplyChanges = function (evt) {
        var _this = this;
        this.calculateFixedPosition(evt);
        this.dragHelper.move(this.shouldClone, function (pt) { return _this.getSnappedPoint(evt, pt); }, function () {
            _this.visualizerManager.resetConnectionTarget();
            _this.visualizerManager.resetConnectionPoints();
        }, function (shape, connectionPointIndex) {
            _this.visualizerManager.setConnectionTarget(shape, Event_1.MouseEventElementType.Shape);
            _this.visualizerManager.setConnectionPoints(shape, Event_1.MouseEventElementType.Shape, connectionPointIndex, true);
        });
        var container = ModelUtils_1.ModelUtils.findContainerByEventKey(this.model, this.selection, evt.source.key);
        if (container && this.allowInsertToContainer(evt, container))
            ModelUtils_1.ModelUtils.insertSelectionToContainer(this.history, this.model, this.selection, container);
        else
            ModelUtils_1.ModelUtils.removeSelectionFromContainer(this.history, this.model, this.selection);
        this.handler.tryUpdateModelSize(function (offsetLeft, offsetTop) { return _this.dragHelper.onTryUpdateModelSize(offsetLeft, offsetTop); });
    };
    MouseHandlerDragDiagramItemStateBase.prototype.getDraggingElementKeys = function () {
        return this.dragHelper.draggingShapes.map(function (x) { return x.shape.key; }).concat(this.dragHelper.draggingConnectors.map(function (x) { return x.connector.key; }));
    };
    MouseHandlerDragDiagramItemStateBase.prototype.getSnappedPoint = function (evt, point) {
        return this.handler.getSnappedPointOnDragDiagramItem(evt, point, this.fixedX, this.fixedY, this.startPoint);
    };
    MouseHandlerDragDiagramItemStateBase.prototype.initDrag = function () {
        this.dragHelper = new DragHelper_1.SelectionDragHelper(this.history, this.model, this.handler.permissionsProvider, this.startPoint, this.selection.getSelectedItems(true));
        this.initDraggingShapes();
        if (!this.areValidDraggingShapes) {
            this.handler.switchToDefaultState();
            return;
        }
        this.initDraggingConnectors();
        if (!this.areValidDraggingConnectors) {
            this.handler.switchToDefaultState();
            return;
        }
    };
    MouseHandlerDragDiagramItemStateBase.prototype.initDraggingShapes = function () {
        this.dragHelper.initDraggingShapes(this.selection.getSelectedShapes(false, true), this.shouldClone);
    };
    MouseHandlerDragDiagramItemStateBase.prototype.initDraggingConnectors = function () {
        this.dragHelper.initDraggingConnectors(this.selection.getSelectedConnectors(false, true), this.shouldClone);
    };
    MouseHandlerDragDiagramItemStateBase.prototype.copySelection = function () {
        var _this = this;
        ModelUtils_1.ModelUtils.cloneSelectionToOffset(this.history, this.model, function (key) {
            var item = _this.model.findItem(key);
            if (item)
                _this.handler.addInteractingItem(item, ModelOperationSettings_1.DiagramModelOperation.AddShape);
        }, this.selection, 0, 0);
    };
    MouseHandlerDragDiagramItemStateBase.prototype.calculateFixedPosition = function (evt) {
        this.fixedX = false;
        this.fixedY = false;
        if (this.handler.canCalculateFixedPosition(evt)) {
            var dx = Math.abs(this.startPoint.x - evt.modelPoint.x);
            var dy = Math.abs(this.startPoint.y - evt.modelPoint.y);
            if (dx < dy)
                this.fixedX = true;
            else
                this.fixedY = true;
        }
    };
    MouseHandlerDragDiagramItemStateBase.prototype.allowInsertToContainer = function (evt, container) {
        if (this.handler.canMultipleSelection(evt))
            return false;
        return container && container.expanded && ModelUtils_1.ModelUtils.canInsertSelectionToContainer(this.model, this.selection, container);
    };
    return MouseHandlerDragDiagramItemStateBase;
}(MouseHandlerDraggingState_1.MouseHandlerDraggingState));
exports.MouseHandlerDragDiagramItemStateBase = MouseHandlerDragDiagramItemStateBase;
//# sourceMappingURL=MouseHandlerDragDiagramItemStateBase.js.map