"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DraggingConnector = exports.SelectionDragHelper = void 0;
var vector_1 = require("@devexpress/utils/lib/geometry/vector");
var ChangeConnectorPointsHistoryItem_1 = require("../../History/Common/ChangeConnectorPointsHistoryItem");
var ConnectorRenderPointsContext_1 = require("../Connectors/Routing/ConnectorRenderPointsContext");
var ModelUtils_1 = require("../ModelUtils");
var ConnectorRenderPoint_1 = require("../Connectors/ConnectorRenderPoint");
var ModelOperationSettings_1 = require("../../ModelOperationSettings");
var SelectionDragHelper = (function () {
    function SelectionDragHelper(history, model, permissionsProvider, startPoint, selectedItems) {
        var _this = this;
        this.history = history;
        this.model = model;
        this.permissionsProvider = permissionsProvider;
        this.startPoint = startPoint;
        this.draggingShapes = [];
        this.draggingConnectors = [];
        this.selectedItems = {};
        this.draggingConnectorsIndexByKey = {};
        selectedItems.forEach(function (i) { return _this.selectedItems[i.key] = i; });
    }
    SelectionDragHelper.prototype.initDraggingShapes = function (shapes, shouldClone) {
        var _this = this;
        this.draggingShapes = shapes.map(function (s) { return new DraggingShape(s); });
        if (!shouldClone)
            this.draggingShapes.forEach(function (draggingShape) { return _this.permissionsProvider.addInteractingItem(draggingShape.shape, ModelOperationSettings_1.DiagramModelOperation.MoveShape); });
    };
    SelectionDragHelper.prototype.initDraggingConnectors = function (connectors, shouldClone) {
        var _this = this;
        this.draggingConnectors = [];
        this.draggingConnectorsIndexByKey = {};
        connectors.forEach(function (c) { return _this.registerConnector(c); });
        if (!shouldClone)
            this.draggingShapes.forEach(function (x) {
                var attachedConnectors = x.shape.attachedConnectors;
                if (attachedConnectors)
                    attachedConnectors.forEach(function (c) {
                        if (!_this.containsDraggingConnectorByKey(c.key))
                            _this.registerConnector(c);
                    });
            });
        this.modelConnectorsWithoutBeginItemInfo = this.createModelConnectorsWithoutBeginItemInfo();
        this.modelConnectorsWithoutEndItemInfo = this.createModelConnectorsWithoutEndItemInfo();
    };
    SelectionDragHelper.prototype.move = function (shouldClone, getMovePoint, resetTargetCallback, updateTargetCallback) {
        var _this = this;
        if (this.draggingShapes.length) {
            var selectedShapes_1 = this.draggingShapes.map(function (ds) { return ds.shape; });
            this.draggingShapes.forEach(function (ds) {
                var shape = ds.shape;
                while (shape.container) {
                    if (selectedShapes_1.indexOf(shape.container) !== -1)
                        return false;
                    shape = shape.container;
                }
                _this.moveShape(ds, getMovePoint, resetTargetCallback, updateTargetCallback);
            });
            var firstDraggingShape = this.draggingShapes[0];
            var offset_1 = vector_1.Vector.fromPoints(firstDraggingShape.startPosition.clone(), firstDraggingShape.shape.position.clone());
            if (offset_1.x || offset_1.y)
                this.draggingConnectors.forEach(function (dc) { return _this.moveConnectorCore(dc.connector, dc.startPoints, dc.startRenderContext, offset_1, shouldClone); });
        }
        else
            this.draggingConnectors.forEach(function (x) { return _this.moveConnector(x, shouldClone, getMovePoint); });
    };
    SelectionDragHelper.prototype.containsDraggingConnectorByKey = function (key) {
        return this.draggingConnectorsIndexByKey[key] !== undefined;
    };
    SelectionDragHelper.prototype.onTryUpdateModelSize = function (offsetLeft, offsetTop) {
        this.modelConnectorsWithoutBeginItemInfo.forEach(function (pi) {
            pi.point.x += offsetLeft;
            pi.point.y += offsetTop;
        });
        this.modelConnectorsWithoutEndItemInfo.forEach(function (pi) {
            pi.point.x += offsetLeft;
            pi.point.y += offsetTop;
        });
    };
    SelectionDragHelper.prototype.moveConnector = function (dc, shouldClone, getMovePoint) {
        var startPoints = dc.startPoints;
        var offset = vector_1.Vector.fromPoints(startPoints[0].clone(), getMovePoint(startPoints[0]).clone());
        if (offset.x || offset.y)
            this.moveConnectorCore(dc.connector, startPoints, dc.startRenderContext, offset, shouldClone);
    };
    SelectionDragHelper.prototype.moveConnectorCore = function (connector, startPoints, startRenderContext, offset, shouldClone) {
        if (shouldClone || ModelUtils_1.ModelUtils.canMoveConnector(this.selectedItems, connector))
            this.offsetConnector(connector, startPoints, startRenderContext, offset);
        else
            this.changeConnector(connector);
    };
    SelectionDragHelper.prototype.moveShape = function (ds, getMovePoint, resetTargetCallback, updateTargetCallback) {
        var _this = this;
        var shape = ds.shape;
        var position = getMovePoint(ds.startPosition);
        ModelUtils_1.ModelUtils.setShapePosition(this.history, this.model, shape, position);
        ModelUtils_1.ModelUtils.updateMovingShapeConnections(this.history, shape, this.modelConnectorsWithoutBeginItemInfo, this.modelConnectorsWithoutEndItemInfo, resetTargetCallback, updateTargetCallback, function (connector) { return _this.permissionsProvider.addInteractingItem(connector); });
        if (!this.draggingConnectors.filter(function (dc) { return !!_this.selectedItems[dc.connector.key]; }).length)
            ModelUtils_1.ModelUtils.updateShapeAttachedConnectors(this.history, this.model, shape);
    };
    SelectionDragHelper.prototype.offsetConnector = function (connector, startPoints, startRenderContext, offset) {
        var _this = this;
        var newPoints = startPoints.map(function (p) { return _this.offsetPoint(p, offset); });
        if (!newPoints[0].equals(connector.points[0]))
            this.history.addAndRedo(new ChangeConnectorPointsHistoryItem_1.ChangeConnectorPointsHistoryItem(connector.key, newPoints, this.offsetRenderContext(startRenderContext, offset)));
    };
    SelectionDragHelper.prototype.offsetRenderContext = function (context, offset) {
        var _this = this;
        if (context === undefined)
            return undefined;
        return new ConnectorRenderPointsContext_1.ConnectorRenderPointsContext(context.renderPoints.map(function (p) {
            var newPoint = _this.offsetPoint(p, offset);
            return new ConnectorRenderPoint_1.ConnectorRenderPoint(newPoint.x, newPoint.y, p.pointIndex, p.skipped);
        }), true, context.actualRoutingMode);
    };
    SelectionDragHelper.prototype.offsetPoint = function (point, offset) {
        var pointOffset = vector_1.Vector.fromPoints(point, this.startPoint);
        return this.startPoint.clone().offset(offset.x - pointOffset.x, offset.y - pointOffset.y);
    };
    SelectionDragHelper.prototype.changeConnector = function (connector) {
        ModelUtils_1.ModelUtils.tryRemoveConnectorIntermediatePoints(this.history, connector);
        ModelUtils_1.ModelUtils.updateConnectorAttachedPoints(this.history, this.model, connector);
    };
    SelectionDragHelper.prototype.registerConnector = function (connector) {
        this.draggingConnectorsIndexByKey[connector.key] = this.draggingConnectors.push(new DraggingConnector(connector)) - 1;
    };
    SelectionDragHelper.prototype.createModelConnectorsWithoutBeginItemInfo = function () {
        var _this = this;
        var connectors = this.model.findConnectorsCore(function (c) { return !c.beginItem && !_this.containsDraggingConnectorByKey(c.key); });
        return connectors.map(function (c) {
            return {
                connector: c,
                point: c.points[0].clone()
            };
        });
    };
    SelectionDragHelper.prototype.createModelConnectorsWithoutEndItemInfo = function () {
        var _this = this;
        var connectors = this.model.findConnectorsCore(function (c) { return !c.endItem && !_this.containsDraggingConnectorByKey(c.key); });
        return connectors.map(function (c) {
            return {
                connector: c,
                point: c.points[c.points.length - 1].clone()
            };
        });
    };
    return SelectionDragHelper;
}());
exports.SelectionDragHelper = SelectionDragHelper;
var DraggingConnector = (function () {
    function DraggingConnector(connector) {
        this.connector = connector;
        this.startPoints = connector.points.map(function (x) { return x.clone(); });
        this.startRenderContext = connector.tryCreateRenderPointsContext();
    }
    return DraggingConnector;
}());
exports.DraggingConnector = DraggingConnector;
var DraggingShape = (function () {
    function DraggingShape(shape) {
        this.shape = shape;
        this.startPosition = shape.position.clone();
    }
    return DraggingShape;
}());
//# sourceMappingURL=DragHelper.js.map