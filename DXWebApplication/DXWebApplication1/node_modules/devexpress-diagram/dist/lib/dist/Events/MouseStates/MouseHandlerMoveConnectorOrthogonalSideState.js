"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.MouseHandlerMoveConnectorOrthogonalSideState = void 0;
var point_1 = require("@devexpress/utils/lib/geometry/point");
var Connector_1 = require("../../Model/Connectors/Connector");
var DiagramItem_1 = require("../../Model/DiagramItem");
var ModelUtils_1 = require("../../Model/ModelUtils");
var MouseHandlerDraggingState_1 = require("./MouseHandlerDraggingState");
var Utils_1 = require("../../Utils");
var MouseHandlerMoveConnectorOrthogonalSideState = (function (_super) {
    __extends(MouseHandlerMoveConnectorOrthogonalSideState, _super);
    function MouseHandlerMoveConnectorOrthogonalSideState(handler, history, model) {
        var _this = _super.call(this, handler, history) || this;
        _this.model = model;
        _this.canCreatePoints = true;
        return _this;
    }
    MouseHandlerMoveConnectorOrthogonalSideState.prototype.saveSidePoints = function (markLeftRenderPointIndex, markRightRenderPointIndex) {
        var _this = this;
        var renderPoints = this.connector.getRenderPoints(true);
        this.isHorizontal = renderPoints[markLeftRenderPointIndex].y === renderPoints[markRightRenderPointIndex].y;
        this.iterateRenderPoints(renderPoints, markLeftRenderPointIndex, false, function (pt, i) {
            if (pt.pointIndex !== -1)
                _this.leftPointIndex = pt.pointIndex;
            _this.leftRenderPointIndex = i;
        }, function (pt) { return !Utils_1.GeometryUtils.arePointsOfOrthogonalLine(renderPoints[markLeftRenderPointIndex], pt, _this.isHorizontal); });
        this.iterateRenderPoints(renderPoints, this.leftRenderPointIndex, true, function (pt, i) {
            if (pt.pointIndex !== -1)
                _this.rightPointIndex = pt.pointIndex;
            _this.rightRenderPointIndex = i;
        }, function (pt) { return !Utils_1.GeometryUtils.arePointsOfOrthogonalLine(renderPoints[markLeftRenderPointIndex], pt, _this.isHorizontal); });
    };
    MouseHandlerMoveConnectorOrthogonalSideState.prototype.iterateRenderPoints = function (renderPoints, startIndex, direction, callback, stopPredicate) {
        for (var i = startIndex; direction ? i < renderPoints.length : i >= 0; direction ? i++ : i--) {
            var point = renderPoints[i];
            if (stopPredicate && stopPredicate(point, i))
                break;
            callback(point, i);
        }
    };
    MouseHandlerMoveConnectorOrthogonalSideState.prototype.onMouseDown = function (evt) {
        this.startPoint = evt.modelPoint;
        this.connector = this.model.findConnector(evt.source.key);
        this.handler.addInteractingItem(this.connector);
        var renderPointIndexes = evt.source.value.split("_");
        this.saveSidePoints(parseInt(renderPointIndexes[0]), parseInt(renderPointIndexes[1]));
        _super.prototype.onMouseDown.call(this, evt);
    };
    MouseHandlerMoveConnectorOrthogonalSideState.prototype.shouldCreatePoint = function (isLeft) {
        if (!this.canCreatePoints)
            return false;
        if (isLeft && (this.leftPointIndex === undefined || this.leftPointIndex === 0))
            return true;
        if (!isLeft && (this.rightPointIndex === undefined || this.rightPointIndex === this.connector.points.length - 1))
            return true;
        var renderPoints = this.connector.getRenderPoints(true);
        if (isLeft && !this.connector.points[this.leftPointIndex].equals(renderPoints[this.leftRenderPointIndex]))
            return true;
        if (!isLeft && !this.connector.points[this.rightPointIndex].equals(renderPoints[this.rightRenderPointIndex]))
            return true;
        return false;
    };
    MouseHandlerMoveConnectorOrthogonalSideState.prototype.onApplyChanges = function (evt) {
        var _this = this;
        if (this.shouldCreatePoint(true) || this.shouldCreatePoint(false)) {
            var renderPoints = this.connector.getRenderPoints(true);
            var leftRenderPoint = renderPoints[this.leftRenderPointIndex];
            var rightRenderPoint = renderPoints[this.rightRenderPointIndex];
            if (this.shouldCreatePoint(true)) {
                var leftPoint = new point_1.Point(leftRenderPoint.x, leftRenderPoint.y);
                if (this.leftPointIndex === 0) {
                    this.leftPointIndex = 1;
                    this.correctEdgePoint(leftPoint, rightRenderPoint, this.connector.beginItem, this.connector.beginConnectionPointIndex);
                }
                else if (this.leftPointIndex === undefined)
                    this.iterateRenderPoints(renderPoints, this.leftRenderPointIndex, true, function (pt) {
                        if (pt.pointIndex !== -1)
                            _this.leftPointIndex = pt.pointIndex;
                    }, function () { return _this.leftPointIndex !== undefined; });
                ModelUtils_1.ModelUtils.addConnectorPoint(this.history, this.connector.key, this.leftPointIndex, leftPoint);
                if (this.rightPointIndex !== undefined)
                    this.rightPointIndex++;
            }
            if (this.shouldCreatePoint(false)) {
                renderPoints = this.connector.getRenderPoints(true);
                var rightPoint = new point_1.Point(rightRenderPoint.x, rightRenderPoint.y);
                if (this.rightPointIndex === this.connector.points.length - 1) {
                    this.correctEdgePoint(rightPoint, leftRenderPoint, this.connector.endItem, this.connector.endConnectionPointIndex);
                    this.rightPointIndex--;
                }
                else if (this.rightPointIndex === undefined)
                    this.iterateRenderPoints(renderPoints, this.rightRenderPointIndex, false, function (pt) {
                        if (pt.pointIndex !== -1)
                            _this.rightPointIndex = pt.pointIndex;
                    }, function () { return _this.rightPointIndex === _this.leftPointIndex; });
                this.rightPointIndex++;
                ModelUtils_1.ModelUtils.addConnectorPoint(this.history, this.connector.key, this.rightPointIndex, rightPoint);
            }
        }
        this.canCreatePoints = false;
        var point = this.getSnappedPoint(evt, evt.modelPoint);
        ModelUtils_1.ModelUtils.moveConnectorRightAnglePoints(this.history, this.connector, this.leftPointIndex, this.rightPointIndex, this.isHorizontal ? undefined : point.x, this.isHorizontal ? point.y : undefined);
        this.handler.tryUpdateModelSize();
    };
    MouseHandlerMoveConnectorOrthogonalSideState.prototype.onFinishWithChanges = function () {
        ModelUtils_1.ModelUtils.deleteConnectorUnnecessaryPoints(this.history, this.connector);
        ModelUtils_1.ModelUtils.fixConnectorBeginEndConnectionIndex(this.history, this.connector);
        this.handler.tryUpdateModelSize();
    };
    MouseHandlerMoveConnectorOrthogonalSideState.prototype.correctEdgePoint = function (point, directionPoint, item, connectionPointIndex) {
        var offset = 0;
        if (item) {
            var side = item.getConnectionPointSideByIndex(connectionPointIndex);
            var rect = item.rectangle;
            offset = Connector_1.Connector.minOffset;
            switch (side) {
                case DiagramItem_1.ConnectionPointSide.South:
                    offset += rect.bottom - point.y;
                    break;
                case DiagramItem_1.ConnectionPointSide.North:
                    offset += point.y - rect.y;
                    break;
                case DiagramItem_1.ConnectionPointSide.East:
                    offset += rect.right - point.x;
                    break;
                case DiagramItem_1.ConnectionPointSide.West:
                    offset += point.x - rect.x;
                    break;
            }
        }
        if (this.isHorizontal)
            if (point.x > directionPoint.x)
                point.x -= Math.min(offset, point.x - directionPoint.x);
            else
                point.x += Math.min(offset, directionPoint.x - point.x);
        else if (point.y > directionPoint.y)
            point.y -= Math.min(offset, point.y - directionPoint.y);
        else
            point.y += Math.min(offset, directionPoint.y - point.y);
    };
    MouseHandlerMoveConnectorOrthogonalSideState.prototype.getDraggingElementKeys = function () {
        return [this.connector.key];
    };
    return MouseHandlerMoveConnectorOrthogonalSideState;
}(MouseHandlerDraggingState_1.MouseHandlerDraggingState));
exports.MouseHandlerMoveConnectorOrthogonalSideState = MouseHandlerMoveConnectorOrthogonalSideState;
//# sourceMappingURL=MouseHandlerMoveConnectorOrthogonalSideState.js.map