"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataSource = void 0;
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var point_1 = require("@devexpress/utils/lib/geometry/point");
var size_1 = require("@devexpress/utils/lib/geometry/size");
var AddConnectionHistoryItem_1 = require("../History/Common/AddConnectionHistoryItem");
var AddConnectorHistoryItem_1 = require("../History/Common/AddConnectorHistoryItem");
var AddShapeHistoryItem_1 = require("../History/Common/AddShapeHistoryItem");
var DeleteConnectionHistoryItem_1 = require("../History/Common/DeleteConnectionHistoryItem");
var ResizeShapeHistoryItem_1 = require("../History/Common/ResizeShapeHistoryItem");
var ChangeConnectorPropertyHistoryItem_1 = require("../History/Properties/ChangeConnectorPropertyHistoryItem");
var ChangeConnectorTextHistoryItem_1 = require("../History/Properties/ChangeConnectorTextHistoryItem");
var ChangeCustomDataHistoryItem_1 = require("../History/Properties/ChangeCustomDataHistoryItem");
var ChangeLockedHistoryItem_1 = require("../History/Properties/ChangeLockedHistoryItem");
var ChangeShapeImageHistoryItem_1 = require("../History/Properties/ChangeShapeImageHistoryItem");
var ChangeShapeTextHistoryItem_1 = require("../History/Properties/ChangeShapeTextHistoryItem");
var ChangeZindexHistoryItem_1 = require("../History/Properties/ChangeZindexHistoryItem");
var ChangeStyleHistoryItem_1 = require("../History/StyleProperties/ChangeStyleHistoryItem");
var ChangeStyleTextHistoryItem_1 = require("../History/StyleProperties/ChangeStyleTextHistoryItem");
var Connector_1 = require("../Model/Connectors/Connector");
var ModelUtils_1 = require("../Model/ModelUtils");
var ShapeTypes_1 = require("../Model/Shapes/ShapeTypes");
var ITextMeasurer_1 = require("../Render/Measurer/ITextMeasurer");
var Utils_1 = require("../Utils");
var color_1 = require("@devexpress/utils/lib/utils/color");
var Data_1 = require("../Utils/Data");
var Svg_1 = require("../Utils/Svg");
var TextUtils_1 = require("../Utils/TextUtils");
var DataImporter_1 = require("./DataImporter");
var DataSourceItems_1 = require("./DataSourceItems");
var ChangeConnectorPointsHistoryItem_1 = require("../History/Common/ChangeConnectorPointsHistoryItem");
var DataSource = (function () {
    function DataSource(key, nodeDataSource, edgeDataSource, parameters, nodeDataImporter, edgeDataImporter) {
        this.key = key;
        this.nodes = [];
        this.edges = [];
        this.autoGeneratedDataKeys = {};
        this.addInternalKeyOnInsert = false;
        this.useNodeParentId = false;
        this.useNodeContainerId = false;
        this.useNodeChildren = false;
        this.useNodeItems = false;
        this.canUseAutoSize = false;
        this.canUpdateEdgeDataSource = false;
        this.containers = null;
        if (key === undefined || key === null)
            throw new Error("DataSource key must be specified");
        this.key = key.toString();
        this.loadParameters(parameters || {});
        this.nodeDataImporter = this.createNodeDataImporter(nodeDataImporter);
        this.edgeDataImporter = this.createEdgeDataImporter(edgeDataImporter);
        this.nodeDataSource = nodeDataSource || [];
        this.edgeDataSource = edgeDataSource || [];
        this.canUpdateEdgeDataSource = !!edgeDataSource;
        this.fetchData();
    }
    DataSource.prototype.loadParameters = function (parameters) {
        this.addInternalKeyOnInsert = !!parameters.addInternalKeyOnInsert;
    };
    DataSource.prototype.isAutoGeneratedKey = function (dataKey) {
        return dataKey && !!this.autoGeneratedDataKeys[dataKey];
    };
    DataSource.prototype.createNodeDataImporter = function (source) {
        var result = new DataImporter_1.DataSourceNodeDataImporter();
        if (source)
            this.assignNodeDataImporterProperties(source, result);
        return result;
    };
    DataSource.prototype.createEdgeDataImporter = function (source) {
        var result = new DataImporter_1.DataSourceEdgeDataImporter();
        if (source)
            this.assignEdgeDataImporterProperties(source, result);
        return result;
    };
    DataSource.prototype.assignItemDataImporterProperties = function (source, importer) {
        if (source.getKey)
            importer.getKey = source.getKey;
        if (source.setKey)
            importer.setKey = source.setKey;
        if (source.getCustomData)
            importer.getCustomData = source.getCustomData;
        if (source.setCustomData)
            importer.setCustomData = source.setCustomData;
        if (source.getLocked)
            importer.getLocked = source.getLocked;
        if (source.setLocked)
            importer.setLocked = source.setLocked;
        if (source.getStyle)
            importer.getStyle = source.getStyle;
        if (source.setStyle)
            importer.setStyle = source.setStyle;
        if (source.getStyleText)
            importer.getStyleText = source.getStyleText;
        if (source.setStyleText)
            importer.setStyleText = source.setStyleText;
        if (source.getZIndex)
            importer.getZIndex = source.getZIndex;
        if (source.setZIndex)
            importer.setZIndex = source.setZIndex;
    };
    DataSource.prototype.assignNodeDataImporterProperties = function (source, importer) {
        this.assignItemDataImporterProperties(source, importer);
        if (source.getType)
            importer.getType = source.getType;
        if (source.setType)
            importer.setType = source.setType;
        if (source.getImage)
            importer.getImage = source.getImage;
        if (source.setImage)
            importer.setImage = source.setImage;
        if (source.getText)
            importer.getText = source.getText;
        if (source.setText)
            importer.setText = source.setText;
        if (source.getLeft)
            importer.getLeft = source.getLeft;
        if (source.setLeft)
            importer.setLeft = source.setLeft;
        if (source.getTop)
            importer.getTop = source.getTop;
        if (source.setTop)
            importer.setTop = source.setTop;
        if (source.getWidth)
            importer.getWidth = source.getWidth;
        if (source.setWidth)
            importer.setWidth = source.setWidth;
        if (source.getHeight)
            importer.getHeight = source.getHeight;
        if (source.setHeight)
            importer.setHeight = source.setHeight;
        if (source.getChildren)
            importer.getChildren = source.getChildren;
        if (source.setChildren)
            importer.setChildren = source.setChildren;
        if (source.getParentKey)
            importer.getParentKey = source.getParentKey;
        if (source.setParentKey)
            importer.setParentKey = source.setParentKey;
        if (source.getItems)
            importer.getItems = source.getItems;
        if (source.setItems)
            importer.setItems = source.setItems;
        if (source.getContainerKey)
            importer.getContainerKey = source.getContainerKey;
        if (source.setContainerKey)
            importer.setContainerKey = source.setContainerKey;
    };
    DataSource.prototype.assignEdgeDataImporterProperties = function (source, importer) {
        this.assignItemDataImporterProperties(source, importer);
        if (source.getFrom)
            importer.getFrom = source.getFrom;
        if (source.setFrom)
            importer.setFrom = source.setFrom;
        if (source.getFromPointIndex)
            importer.getFromPointIndex = source.getFromPointIndex;
        if (source.setFromPointIndex)
            importer.setFromPointIndex = source.setFromPointIndex;
        if (source.getTo)
            importer.getTo = source.getTo;
        if (source.setTo)
            importer.setTo = source.setTo;
        if (source.getToPointIndex)
            importer.getToPointIndex = source.getToPointIndex;
        if (source.setToPointIndex)
            importer.setToPointIndex = source.setToPointIndex;
        if (source.getPoints)
            importer.getPoints = source.getPoints;
        if (source.setPoints)
            importer.setPoints = source.setPoints;
        if (source.getText)
            importer.getText = source.getText;
        if (source.setText)
            importer.setText = source.setText;
        if (source.getLineOption)
            importer.getLineOption = source.getLineOption;
        if (source.setLineOption)
            importer.setLineOption = source.setLineOption;
        if (source.getStartLineEnding)
            importer.getStartLineEnding = source.getStartLineEnding;
        if (source.setStartLineEnding)
            importer.setStartLineEnding = source.setStartLineEnding;
        if (source.getEndLineEnding)
            importer.getEndLineEnding = source.getEndLineEnding;
        if (source.setEndLineEnding)
            importer.setEndLineEnding = source.setEndLineEnding;
    };
    DataSource.prototype.fetchData = function () {
        var _this = this;
        this.nodes = [];
        this.edges = [];
        this.autoGeneratedDataKeys = {};
        this.useNodeParentId = this.nodeDataImporter.getParentKey !== undefined;
        this.useNodeContainerId = this.nodeDataImporter.getContainerKey !== undefined;
        this.useNodeItems = this.nodeDataImporter.getItems !== undefined;
        this.useNodeChildren = this.nodeDataImporter.getChildren !== undefined;
        this.canUseAutoSize = this.nodeDataImporter.getWidth === undefined && this.nodeDataImporter.getText !== undefined;
        if (this.useEdgesArray() && this.useNodeParentId)
            throw new Error("You cannot use edges array and parentKey simultaneously.");
        if (this.useEdgesArray() && this.useNodeItems)
            throw new Error("You cannot use edges array and items array simultaneously.");
        if (this.useNodeParentId && this.useNodeItems)
            throw new Error("You cannot use parentKey and items array simultaneously.");
        if (this.useNodeContainerId && this.useNodeChildren)
            throw new Error("You cannot use containerKey and children array simultaneously.");
        this.nodeDataSource.forEach(function (nodeDataObj) {
            _this.addNode(nodeDataObj);
        });
        if (this.useEdgesArray())
            this.edgeDataSource.forEach(function (edgeDataObj) {
                _this.addEdge(edgeDataObj);
            });
        else
            this.nodes.forEach(function (node) {
                _this.addNodeEdgesByParentId(node);
            });
    };
    DataSource.prototype.isContainer = function (itemKey) {
        var _this = this;
        if (!this.containers && this.useNodeContainerId)
            this.containers = this.nodeDataSource
                .map(function (i) { return _this.nodeDataImporter.getContainerKey(i); })
                .filter(function (i) { return i !== undefined && i !== null; })
                .reduce(function (map, i) {
                map[i] = true;
                return map;
            }, {});
        return this.containers && this.containers[itemKey];
    };
    DataSource.prototype.refetchData = function (nodeDataSource, edgeDataSource) {
        var _this = this;
        this.nodeDataSource = nodeDataSource || this.nodeDataSource;
        this.edgeDataSource = edgeDataSource || this.edgeDataSource;
        var oldNodes = this.nodes.slice();
        var oldEdges = this.edges.slice();
        this.fetchData();
        var changedNodes = this.getItemChanges(oldNodes, this.nodes, function (item1, item2) {
            return (item1.key === item2.key) || (item1.dataObj === item2.dataObj);
        });
        var changedEdges = this.getItemChanges(oldEdges, this.edges, function (item1, item2) {
            if (_this.useNodeParentId || _this.useNodeItems)
                return (item1.key === item2.key) || (item1.from === item2.from && item1.to === item2.to);
            return (item1.key === item2.key) || (item1.dataObj === item2.dataObj);
        });
        return { nodes: changedNodes, edges: changedEdges };
    };
    DataSource.prototype.getItemChanges = function (oldItems, newItems, areEqual) {
        var _this = this;
        var remainedItems = oldItems.filter(function (item) { return _this.containsItem(newItems, item, areEqual); });
        var removedItems = oldItems.filter(function (item) { return !_this.containsItem(newItems, item, areEqual); });
        var addedItems = newItems.filter(function (item) { return !_this.containsItem(oldItems, item, areEqual); });
        return {
            remained: remainedItems.map(function (item) { return item.key; }),
            remainedNewKeys: remainedItems.map(function (item) { var _a; return (_a = newItems.find(function (i) { return areEqual(item, i); })) === null || _a === void 0 ? void 0 : _a.key; }),
            removed: removedItems.map(function (item) { return item.key; }),
            added: addedItems.map(function (item) { return item.key; })
        };
    };
    DataSource.prototype.containsItem = function (items, item, areEqual) {
        var result = false;
        items.forEach(function (i) {
            if (!result && areEqual(i, item))
                result = true;
        });
        return result;
    };
    DataSource.prototype.useEdgesArray = function () {
        return Array.isArray(this.edgeDataSource) && (this.edgeDataSource.length || !(this.useNodeParentId || this.useNodeItems));
    };
    DataSource.prototype.addNode = function (nodeDataObj, parentNodeDataObj, containerKey, containerNodeDataObj) {
        var _this = this;
        var childNodeDataObjs = this.nodeDataImporter.getChildren && this.nodeDataImporter.getChildren(nodeDataObj);
        var hasChildren = childNodeDataObjs && Array.isArray(childNodeDataObjs) && childNodeDataObjs.length;
        var isContainer = hasChildren || this.isContainer(this.nodeDataImporter.getKey(nodeDataObj));
        var type = this.nodeDataImporter.getType && this.nodeDataImporter.getType(nodeDataObj) || (isContainer && ShapeTypes_1.ShapeTypes.VerticalContainer) || ShapeTypes_1.ShapeTypes.Rectangle;
        var text = this.nodeDataImporter.getText && (this.nodeDataImporter.getText(nodeDataObj) || "");
        var node = this.addNodeInternal(nodeDataObj, type, text, parentNodeDataObj, containerKey, containerNodeDataObj);
        this.assignNodeProperties(node, nodeDataObj);
        if (hasChildren)
            childNodeDataObjs.forEach(function (childNodeDataObj) {
                _this.addNode(childNodeDataObj, undefined, node.key, nodeDataObj);
            });
        if (this.useNodeItems) {
            var itemDataObjs = this.nodeDataImporter.getItems(nodeDataObj);
            if (Array.isArray(itemDataObjs) && itemDataObjs.length)
                itemDataObjs.forEach(function (itemDataObj) {
                    var itemNode = _this.addNode(itemDataObj, nodeDataObj, containerKey, containerNodeDataObj);
                    _this.addEdgeInternal(undefined, node.key, itemNode.key);
                });
        }
        return node;
    };
    DataSource.prototype.addNodeEdgesByParentId = function (node) {
        if (this.useNodeParentId) {
            var parentKey = this.nodeDataImporter.getParentKey(node.dataObj);
            if (parentKey !== undefined && parentKey !== null) {
                var parentNode = this.findNode(parentKey);
                if (parentNode)
                    this.addEdgeInternal(undefined, this.getNodeKey(node.dataObj, this.nodeDataImporter.getParentKey), this.getNodeKey(node.dataObj, this.nodeDataImporter.getKey));
            }
        }
    };
    DataSource.prototype.addNodeInternal = function (nodeDataObj, type, text, parentNodeDataObj, containerKey, containerNodeDataObj) {
        var externalKey = this.nodeDataImporter.getKey(nodeDataObj);
        var key = (externalKey !== undefined && externalKey !== null) ? externalKey : ModelUtils_1.ModelUtils.getGuidItemKey();
        var node = new DataSourceItems_1.DataSourceNodeItem(this.key, key, nodeDataObj, type, text, parentNodeDataObj, containerKey, containerNodeDataObj);
        this.nodes.push(node);
        if (externalKey === undefined || externalKey === null) {
            externalKey = key;
            this.autoGeneratedDataKeys[key] = true;
        }
        return node;
    };
    DataSource.prototype.addEdge = function (edgeDataObj) {
        var edge = this.addEdgeInternal(edgeDataObj, this.getNodeKey(edgeDataObj, this.edgeDataImporter.getFrom), this.getNodeKey(edgeDataObj, this.edgeDataImporter.getTo));
        this.assignEdgeProperties(edge, edgeDataObj);
        return edge;
    };
    DataSource.prototype.addEdgeInternal = function (edgeDataObj, from, to) {
        var externalKey = edgeDataObj && this.edgeDataImporter.getKey(edgeDataObj);
        var key = (externalKey !== undefined && externalKey !== null) ? externalKey : ModelUtils_1.ModelUtils.getGuidItemKey();
        var edge = new DataSourceItems_1.DataSourceEdgeItem(this.key, key, edgeDataObj, from, to);
        this.edges.push(edge);
        if (externalKey === undefined || externalKey === null) {
            externalKey = key;
            this.autoGeneratedDataKeys[key] = true;
        }
        return edge;
    };
    DataSource.prototype.assignItemProperties = function (item, dataObj, importer) {
        if (importer.getCustomData)
            item.customData = Utils_1.ObjectUtils.cloneObject(importer.getCustomData(dataObj));
        if (importer.getLocked)
            item.locked = importer.getLocked(dataObj);
        if (importer.getStyle) {
            var style = importer.getStyle(dataObj);
            item.style = typeof style === "string" ? Data_1.Data.cssTextToObject(style) : style;
        }
        if (importer.getStyleText) {
            var style = importer.getStyleText(dataObj);
            item.styleText = typeof style === "string" ? Data_1.Data.cssTextToObject(style) : style;
        }
        if (importer.getZIndex)
            item.zIndex = importer.getZIndex(dataObj);
    };
    DataSource.prototype.assignNodeProperties = function (item, dataObj) {
        this.assignItemProperties(item, dataObj, this.nodeDataImporter);
        if (this.nodeDataImporter.getImage)
            item.image = this.nodeDataImporter.getImage(dataObj);
        if (this.nodeDataImporter.getLeft)
            item.left = this.nodeDataImporter.getLeft(dataObj);
        if (this.nodeDataImporter.getTop)
            item.top = this.nodeDataImporter.getTop(dataObj);
        if (this.nodeDataImporter.getWidth)
            item.width = this.nodeDataImporter.getWidth(dataObj);
        if (this.nodeDataImporter.getHeight)
            item.height = this.nodeDataImporter.getHeight(dataObj);
        if (this.nodeDataImporter.getContainerKey)
            item.containerKey = this.nodeDataImporter.getContainerKey(dataObj);
    };
    DataSource.prototype.assignEdgeProperties = function (item, dataObj) {
        this.assignItemProperties(item, dataObj, this.edgeDataImporter);
        if (this.edgeDataImporter.getFromPointIndex)
            item.fromPointIndex = this.edgeDataImporter.getFromPointIndex(dataObj);
        if (this.edgeDataImporter.getToPointIndex)
            item.toPointIndex = this.edgeDataImporter.getToPointIndex(dataObj);
        if (this.edgeDataImporter.getPoints)
            item.points = this.edgeDataImporter.getPoints(dataObj);
        if (this.edgeDataImporter.getText) {
            var texts = this.edgeDataImporter.getText(dataObj);
            item.texts = {};
            if (typeof texts === "object")
                for (var key in texts) {
                    if (!Object.prototype.hasOwnProperty.call(texts, key))
                        continue;
                    var position = parseFloat(key);
                    var text = texts[key];
                    if (!isNaN(position) && typeof text === "string" && text !== "") {
                        position = Math.min(1, Math.max(0, position));
                        item.texts[position] = text;
                    }
                }
            else if (typeof texts === "string" && texts !== "")
                item.texts[Connector_1.CONNECTOR_DEFAULT_TEXT_POSITION] = texts;
        }
        if (this.edgeDataImporter.getLineOption)
            item.lineOption = this.edgeDataImporter.getLineOption(dataObj);
        if (this.edgeDataImporter.getStartLineEnding)
            item.startLineEnding = this.edgeDataImporter.getStartLineEnding(dataObj);
        if (this.edgeDataImporter.getEndLineEnding)
            item.endLineEnding = this.edgeDataImporter.getEndLineEnding(dataObj);
    };
    DataSource.prototype.findNode = function (key) {
        return this.nodes.filter(function (i) { return key !== undefined && i.key === key; })[0];
    };
    DataSource.prototype.findEdge = function (key) {
        return this.edges.filter(function (i) { return key !== undefined && i.key === key; })[0];
    };
    DataSource.prototype.getNodeKey = function (nodeDataObj, getKey) {
        return getKey(nodeDataObj);
    };
    DataSource.prototype.createModelItems = function (history, model, shapeDescriptionManager, selection, layoutParameters, snapToGrid, gridSize, measurer) {
        var _this = this;
        this.beginChangesNotification();
        history.clear();
        history.beginTransaction();
        ModelUtils_1.ModelUtils.deleteAllItems(history, model, selection);
        model.initializeKeyCounter();
        var DEFAULT_STEP = snapToGrid ? Math.max(1, Math.floor(2000 / gridSize)) * gridSize : 2000;
        var rowIndex = 0;
        var colIndex = 0;
        var externalToInnerMap = {};
        var shapes = [];
        var connectors = [];
        this.nodes.forEach(function (node) {
            var point = new point_1.Point(colIndex++ * DEFAULT_STEP, rowIndex * DEFAULT_STEP);
            var shape = _this.createShapeByNode(history, model, selection, shapeDescriptionManager, node, point, layoutParameters, snapToGrid, gridSize, measurer);
            if (node.key !== undefined)
                externalToInnerMap[node.key] = shape.key;
            if (colIndex > 4) {
                colIndex = 0;
                rowIndex++;
            }
            shapes.push(shape);
        });
        this.nodes.forEach(function (node) {
            if (node.containerKey !== undefined && node.containerKey !== null) {
                var shapeKey = externalToInnerMap[node.key];
                var shape = model.findShape(shapeKey);
                var containerShapeKey = externalToInnerMap[node.containerKey];
                var containerShape = model.findShape(containerShapeKey);
                if (containerShape)
                    ModelUtils_1.ModelUtils.insertToContainer(history, model, shape, containerShape);
            }
        });
        this.edges.forEach(function (edge) {
            var toShape = model.findShape(externalToInnerMap[edge.to]);
            var fromShape = model.findShape(externalToInnerMap[edge.from]);
            var connector = _this.createConnectorByEdge(history, model, selection, edge, fromShape, toShape);
            if (connector) {
                connectors.push(connector);
                ModelUtils_1.ModelUtils.updateConnectorContainer(history, model, connector);
            }
        });
        if (layoutParameters.needAutoLayout)
            this.applyLayout(history, model, shapes, connectors, layoutParameters, snapToGrid, gridSize);
        ModelUtils_1.ModelUtils.tryUpdateModelRectangle(history);
        history.endTransaction(true);
        this.endChangesNotification(true);
    };
    DataSource.prototype.updateModelItems = function (history, model, shapeDescriptionManager, selection, layoutParameters, addNewHistoryItem, updateDataKeys, updateTemplateItem, changes, snapToGrid, gridSize, measurer) {
        var _this = this;
        this.beginChangesNotification();
        history.beginTransaction();
        var itemsToUpdate = [];
        var layoutShapes = [];
        var layoutConnectors = [];
        var shapesToRemove = changes.nodes.removed.map(function (key) { return model.findShapeByDataKey(key); }).filter(function (item) { return item; });
        shapesToRemove.forEach(function (shape) {
            shape.attachedConnectors.forEach(function (connector) {
                if (connector.beginItem && connector.beginItem !== shape)
                    layoutShapes.push(connector.beginItem);
                if (connector.endItem && connector.endItem !== shape)
                    layoutShapes.push(connector.endItem);
            });
        });
        ModelUtils_1.ModelUtils.deleteItems(history, model, selection, shapesToRemove, true);
        var connectorsToRemove = changes.edges.removed.map(function (key) { return model.findConnectorByDataKey(key); }).filter(function (item) { return item; });
        connectorsToRemove.forEach(function (connector) {
            if (connector.beginItem)
                layoutShapes.push(connector.beginItem);
            if (connector.endItem)
                layoutShapes.push(connector.endItem);
        });
        ModelUtils_1.ModelUtils.deleteItems(history, model, selection, connectorsToRemove, true);
        layoutShapes = this.purgeLayoutShapes(layoutShapes, shapesToRemove);
        var nodeKeysToUpdate = updateDataKeys || [];
        nodeKeysToUpdate.forEach(function (dataKey) {
            if (changes.nodes.remained.indexOf(dataKey) === -1)
                return;
            var node = _this.findNode(dataKey);
            if (node) {
                var shape = model.findShapeByDataKey(dataKey);
                if (shape) {
                    var position = shape.position.clone();
                    _this.changeShapeByDataItem(history, model, shape, node, position);
                    _this.changeItemByDataItem(history, shape, node);
                }
                else
                    shape = _this.createShapeByNode(history, model, selection, shapeDescriptionManager, node, new point_1.Point(0, 0), layoutParameters, snapToGrid, gridSize, measurer);
                _this.updateShapeContainer(history, model, shape, node);
                layoutShapes.push(shape);
                itemsToUpdate.push(shape);
            }
        });
        changes.nodes.remained.forEach(function (dataKey, index) {
            var shape = model.findShapeByDataKey(dataKey);
            if (shape)
                shape.dataKey = changes.nodes.remainedNewKeys[index];
        });
        changes.nodes.added.forEach(function (dataKey) {
            var node = _this.findNode(dataKey);
            var shape = _this.createShapeByNode(history, model, selection, shapeDescriptionManager, node, new point_1.Point(0, 0), layoutParameters, snapToGrid, gridSize, measurer);
            _this.updateShapeContainer(history, model, shape, node);
            layoutShapes.push(shape);
        });
        changes.edges.added.forEach(function (dataKey) {
            var edge = _this.findEdge(dataKey);
            var fromShape = model.findShapeByDataKey(edge.from);
            var toShape = model.findShapeByDataKey(edge.to);
            var connector = _this.createConnectorByEdge(history, model, selection, edge, fromShape, toShape);
            if (connector) {
                ModelUtils_1.ModelUtils.updateConnectorContainer(history, model, connector);
                layoutConnectors.push(connector);
            }
        });
        var edgeKeysToUpdate = updateDataKeys || [];
        changes.edges.remained.forEach(function (dataKey) {
            var edge = _this.findEdge(dataKey);
            if (edge && ((changes.nodes.added.indexOf(edge.from) !== -1) || (changes.nodes.added.indexOf(edge.to) !== -1)))
                edgeKeysToUpdate.push(dataKey);
        });
        edgeKeysToUpdate.forEach(function (dataKey) {
            if (changes.edges.remained.indexOf(dataKey) === -1)
                return;
            var edge = _this.findEdge(dataKey);
            if (edge) {
                var fromShape = model.findShapeByDataKey(edge.from);
                var toShape = model.findShapeByDataKey(edge.to);
                var connector = model.findConnectorByDataKey(dataKey);
                if (connector) {
                    _this.changeConnectorPointsByDataItem(history, connector, _this.getConnectorPointsByEdge(model, edge, fromShape, toShape, false));
                    _this.changeConnectorByDataItem(history, model, connector, fromShape, toShape, edge);
                    _this.changeItemByDataItem(history, connector, edge);
                }
                else
                    connector = _this.createConnectorByEdge(history, model, selection, edge, fromShape, toShape);
                if (connector) {
                    ModelUtils_1.ModelUtils.updateConnectorContainer(history, model, connector);
                    layoutConnectors.push(connector);
                    itemsToUpdate.push(connector);
                }
            }
        });
        changes.edges.remained.forEach(function (dataKey, index) {
            var connector = model.findConnectorByDataKey(dataKey);
            if (connector)
                connector.dataKey = changes.edges.remainedNewKeys[index];
        });
        if (itemsToUpdate.length && updateTemplateItem)
            itemsToUpdate.forEach(function (item) { item.hasTemplate && updateTemplateItem(item); });
        if (layoutParameters.needAutoLayout && (layoutShapes.length || layoutConnectors.length))
            this.applyLayout(history, model, layoutShapes, layoutConnectors, layoutParameters, snapToGrid, gridSize);
        ModelUtils_1.ModelUtils.tryUpdateModelRectangle(history);
        history.endTransaction(!addNewHistoryItem);
        this.endChangesNotification(false);
    };
    DataSource.prototype.purgeLayoutShapes = function (layoutShapes, shapesToRemove) {
        var shapesToRemoveKeySet = shapesToRemove.reduce(function (acc, shape) { return (acc[shape.key] = true) && acc; }, {});
        return layoutShapes.reduce(function (acc, shape) {
            if (acc.keySet[shape.key] === undefined && shapesToRemoveKeySet[shape.key] === undefined) {
                acc.uniqueShapes.push(shape);
                acc.keySet[shape.key] = true;
            }
            return acc;
        }, { uniqueShapes: [], keySet: {} }).uniqueShapes;
    };
    DataSource.prototype.applyShapeAutoSize = function (history, measurer, shapeSizeSettings, shape, snapToGrid, gridSize) {
        if (!shape.description.enableText)
            return;
        var shapeTextSize = shape.textRectangle.createSize();
        var shapeSize = shape.size;
        var textHorOffset = shapeTextSize.width - shapeSize.width;
        var textVerOffset = shapeTextSize.height - shapeSize.height;
        var maxWidth = shape.getMaxWidth(shapeSizeSettings.shapeMaxWidth);
        var maxHeight = shape.getMaxHeight(shapeSizeSettings.shapeMaxHeight);
        var sizeToPx = function (size, isHorizontal) { return typeof (size) === "number" ? unit_converter_1.UnitConverter.twipsToPixelsF(size + (isHorizontal ? textHorOffset : textVerOffset)) : undefined; };
        var newShapeTextSize = (0, TextUtils_1.getOptimalTextRectangle)(shape.text, shape.styleText, ITextMeasurer_1.TextOwner.Shape, measurer, shapeTextSize.clone().applyConverter(unit_converter_1.UnitConverter.twipsToPixelsF), shape.description.keepRatioOnAutoSize, sizeToPx(shape.getMinWidth(shapeSizeSettings.shapeMinWidth), true), sizeToPx(maxWidth, true), sizeToPx(shape.getMinHeight(shapeSizeSettings.shapeMinHeight), false), sizeToPx(maxHeight, false))
            .clone().applyConverter(unit_converter_1.UnitConverter.pixelsToTwips);
        if (!newShapeTextSize.equals(shapeTextSize)) {
            var shapeNewSize = shape.description.getSizeByText(newShapeTextSize, shape);
            if (snapToGrid && gridSize)
                shapeNewSize = new size_1.Size(Math.min(gridSize * Math.ceil(shapeNewSize.width / gridSize), maxWidth || Number.MAX_VALUE), Math.min(gridSize * Math.ceil(shapeNewSize.height / gridSize), maxHeight || Number.MAX_VALUE));
            history.addAndRedo(new ResizeShapeHistoryItem_1.ResizeShapeHistoryItem(shape.key, shape.position, shapeNewSize));
        }
    };
    DataSource.prototype.applyLayout = function (history, model, shapes, connectors, layoutParameters, snapToGrid, gridSize) {
        var graphInfo = ModelUtils_1.ModelUtils.getGraphInfoByItems(model, shapes, connectors);
        graphInfo.forEach(function (info) {
            var layout = layoutParameters.getLayoutBuilder(info.graph).build();
            var nonGraphItems = ModelUtils_1.ModelUtils.getNonGraphItems(model, info.container, layout.nodeToLayout, shapes, connectors);
            ModelUtils_1.ModelUtils.applyLayout(history, model, info.container, info.graph, layout, nonGraphItems, layoutParameters.layoutSettings, snapToGrid, gridSize, layoutParameters.skipPointIndices);
        });
    };
    DataSource.prototype.changeItemByDataItem = function (history, item, dataItem) {
        if (dataItem.customData !== undefined && !Utils_1.ObjectUtils.compareObjects(dataItem.customData, item.customData))
            history.addAndRedo(new ChangeCustomDataHistoryItem_1.ChangeCustomDataHistoryItem(item.key, dataItem.customData));
        if (dataItem.zIndex !== undefined && dataItem.zIndex !== item.zIndex)
            history.addAndRedo(new ChangeZindexHistoryItem_1.ChangeZindexHistoryItem(item, dataItem.zIndex));
        if (dataItem.style !== undefined)
            for (var key in dataItem.style) {
                if (!Object.prototype.hasOwnProperty.call(dataItem.style, key))
                    continue;
                var value = this.getPreparedStyleValue(dataItem.style[key], (0, Svg_1.isColorProperty)(key));
                if (value !== item.style[key])
                    history.addAndRedo(new ChangeStyleHistoryItem_1.ChangeStyleHistoryItem(item.key, key, value));
            }
        var defaultStyle = item.style.getDefaultInstance();
        item.style.forEach(function (key) {
            if ((dataItem.style && dataItem.style[key] === undefined) && item.style[key] !== defaultStyle[key])
                history.addAndRedo(new ChangeStyleHistoryItem_1.ChangeStyleHistoryItem(item.key, key, defaultStyle[key]));
        });
        if (dataItem.styleText !== undefined)
            for (var key in dataItem.styleText) {
                if (!Object.prototype.hasOwnProperty.call(dataItem.styleText, key))
                    continue;
                var value = this.getPreparedStyleValue(dataItem.styleText[key], (0, Svg_1.isColorProperty)(key));
                if (value !== item.styleText[key])
                    history.addAndRedo(new ChangeStyleTextHistoryItem_1.ChangeStyleTextHistoryItem(item.key, key, value));
            }
        var defaultTextStyle = item.styleText.getDefaultInstance();
        item.styleText.forEach(function (key) {
            if ((dataItem.styleText && dataItem.styleText[key] === undefined) && item.styleText[key] !== defaultTextStyle[key])
                history.addAndRedo(new ChangeStyleTextHistoryItem_1.ChangeStyleTextHistoryItem(item.key, key, defaultTextStyle[key]));
        });
        if (dataItem.locked !== undefined && dataItem.locked !== item.locked)
            history.addAndRedo(new ChangeLockedHistoryItem_1.ChangeLockedHistoryItem(item, dataItem.locked));
    };
    DataSource.prototype.getPreparedStyleValue = function (value, isColorProperty) {
        if (isColorProperty) {
            var colorValue = color_1.ColorUtils.stringToHash(value);
            if (colorValue !== null)
                value = colorValue;
        }
        return value;
    };
    DataSource.prototype.createShapeByNode = function (history, model, selection, shapeDescriptionManager, node, point, layoutParameters, snapToGrid, gridSize, measurer) {
        var insert = new AddShapeHistoryItem_1.AddShapeHistoryItem(shapeDescriptionManager.get(node.type), point, "", node.key);
        history.addAndRedo(insert);
        var shape = model.findShape(insert.shapeKey);
        ModelUtils_1.ModelUtils.updateNewShapeProperties(history, selection, insert.shapeKey);
        this.changeShapeByDataItem(history, model, shape, node, point);
        this.changeItemByDataItem(history, shape, node);
        if (measurer && this.canUseAutoSize && layoutParameters.autoSizeEnabled)
            this.applyShapeAutoSize(history, measurer, layoutParameters.sizeSettings, shape, snapToGrid, gridSize);
        return shape;
    };
    DataSource.prototype.changeShapeByDataItem = function (history, model, shape, node, point) {
        if (node.left !== undefined)
            point.x = ModelUtils_1.ModelUtils.getTwipsValue(model.units, node.left);
        if (node.top !== undefined)
            point.y = ModelUtils_1.ModelUtils.getTwipsValue(model.units, node.top);
        ModelUtils_1.ModelUtils.setShapePosition(history, model, shape, point, false);
        if (node.type !== undefined)
            ModelUtils_1.ModelUtils.changeShapeType(history, model, shape, node.type);
        var size = shape.size.clone();
        if (node.width !== undefined)
            size.width = ModelUtils_1.ModelUtils.getTwipsValue(model.units, node.width);
        if (node.height !== undefined)
            size.height = ModelUtils_1.ModelUtils.getTwipsValue(model.units, node.height);
        ModelUtils_1.ModelUtils.setShapeSize(history, model, shape, point, size);
        ModelUtils_1.ModelUtils.updateShapeAttachedConnectors(history, model, shape);
        if (node.text !== undefined && node.text !== shape.text)
            history.addAndRedo(new ChangeShapeTextHistoryItem_1.ChangeShapeTextHistoryItem(shape, node.text));
        if (node.image !== undefined && node.image !== shape.image.actualUrl)
            history.addAndRedo(new ChangeShapeImageHistoryItem_1.ChangeShapeImageHistoryItem(shape, node.image));
    };
    DataSource.prototype.updateShapeContainer = function (history, model, shape, node) {
        var containerShape = (node.containerKey !== undefined) ? model.findShapeByDataKey(node.containerKey) : undefined;
        if (containerShape !== shape.container)
            if (containerShape)
                ModelUtils_1.ModelUtils.insertToContainer(history, model, shape, containerShape);
            else
                ModelUtils_1.ModelUtils.removeFromContainer(history, model, shape);
    };
    DataSource.prototype.getConnectorPointsByEdge = function (model, edge, fromShape, toShape, forceCreate) {
        var result = [];
        var modelPoints = this.createModelPointFromDataSourceEdgeItemPoints(model.units, edge);
        if (modelPoints && modelPoints.length > 1) {
            var lastIndex = modelPoints.length - 1;
            for (var i = 0; i <= lastIndex; i++) {
                var modelPoint = modelPoints[i];
                if (modelPoint !== null)
                    result.push(modelPoint);
                else if (!fromShape && !toShape)
                    return undefined;
                else if (i === 0 && fromShape)
                    result.push(fromShape.position.clone());
                else if (i === lastIndex && toShape)
                    result.push(toShape.position.clone());
            }
        }
        else if (forceCreate) {
            if (fromShape)
                result.push(fromShape.position.clone());
            if (toShape)
                result.push(toShape.position.clone());
        }
        return result;
    };
    DataSource.prototype.createModelPointFromDataSourceEdgeItemPoints = function (units, edge) {
        var _this = this;
        var result = [];
        if (!Array.isArray(edge.points))
            return undefined;
        edge.points.forEach(function (dep) { return result.push(_this.isValidDataSourceEdgeItemPoint(dep) ? _this.createModelPoint(units, dep) : null); });
        return result;
    };
    DataSource.prototype.createModelPoint = function (units, point) {
        return new point_1.Point(ModelUtils_1.ModelUtils.getTwipsValue(units, point.x), ModelUtils_1.ModelUtils.getTwipsValue(units, point.y));
    };
    DataSource.prototype.isValidDataSourceEdgeItemPoint = function (point) {
        return point !== undefined && point !== null &&
            point.x !== undefined && point.y !== undefined &&
            point.x !== null && point.y !== null;
    };
    DataSource.prototype.createConnectorByEdge = function (history, model, selection, edge, fromShape, toShape) {
        var connector;
        var dataKey = edge.key;
        var points = this.getConnectorPointsByEdge(model, edge, fromShape, toShape, true);
        if (points && points.length > 1) {
            var insert = new AddConnectorHistoryItem_1.AddConnectorHistoryItem(points, dataKey);
            history.addAndRedo(insert);
            connector = model.findConnector(insert.connectorKey);
            ModelUtils_1.ModelUtils.updateNewConnectorProperties(history, selection, insert.connectorKey);
            this.changeConnectorByDataItem(history, model, connector, fromShape, toShape, edge);
            this.changeItemByDataItem(history, connector, edge);
        }
        return connector;
    };
    DataSource.prototype.changeConnectorByDataItem = function (history, model, connector, fromShape, toShape, edge) {
        var fromPointIndex = edge.fromPointIndex !== undefined ? edge.fromPointIndex : connector.beginConnectionPointIndex;
        if (connector.beginItem !== fromShape || connector.beginConnectionPointIndex !== fromPointIndex) {
            if (connector.beginItem)
                history.addAndRedo(new DeleteConnectionHistoryItem_1.DeleteConnectionHistoryItem(connector, Connector_1.ConnectorPosition.Begin));
            if (fromShape)
                history.addAndRedo(new AddConnectionHistoryItem_1.AddConnectionHistoryItem(connector, fromShape, fromPointIndex, Connector_1.ConnectorPosition.Begin));
        }
        var toPointIndex = edge.toPointIndex !== undefined ? edge.toPointIndex : connector.endConnectionPointIndex;
        if (connector.endItem !== toShape || connector.endConnectionPointIndex !== toPointIndex) {
            if (connector.endItem)
                history.addAndRedo(new DeleteConnectionHistoryItem_1.DeleteConnectionHistoryItem(connector, Connector_1.ConnectorPosition.End));
            if (toShape)
                history.addAndRedo(new AddConnectionHistoryItem_1.AddConnectionHistoryItem(connector, toShape, toPointIndex, Connector_1.ConnectorPosition.End));
        }
        ModelUtils_1.ModelUtils.updateConnectorAttachedPoints(history, model, connector);
        if (edge.texts !== undefined && !this.compareTexts(edge, connector)) {
            connector.texts.forEach(function (text) {
                history.addAndRedo(new ChangeConnectorTextHistoryItem_1.ChangeConnectorTextHistoryItem(connector, text.position, undefined));
            });
            for (var key in edge.texts) {
                if (!Object.prototype.hasOwnProperty.call(edge.texts, key))
                    continue;
                var position = parseFloat(key);
                history.addAndRedo(new ChangeConnectorTextHistoryItem_1.ChangeConnectorTextHistoryItem(connector, position, edge.texts[key]));
            }
        }
        if (edge.lineOption !== undefined && edge.lineOption !== connector.properties.lineOption)
            history.addAndRedo(new ChangeConnectorPropertyHistoryItem_1.ChangeConnectorPropertyHistoryItem(connector.key, "lineOption", edge.lineOption));
        if (edge.startLineEnding !== undefined && edge.startLineEnding !== connector.properties.startLineEnding)
            history.addAndRedo(new ChangeConnectorPropertyHistoryItem_1.ChangeConnectorPropertyHistoryItem(connector.key, "startLineEnding", edge.startLineEnding));
        if (edge.endLineEnding !== undefined && edge.endLineEnding !== connector.properties.endLineEnding)
            history.addAndRedo(new ChangeConnectorPropertyHistoryItem_1.ChangeConnectorPropertyHistoryItem(connector.key, "endLineEnding", edge.endLineEnding));
    };
    DataSource.prototype.changeConnectorPointsByDataItem = function (history, connector, newPoints) {
        if (newPoints && newPoints.length > 1 && newPoints.join(",") !== connector.points.join(","))
            history.addAndRedo(new ChangeConnectorPointsHistoryItem_1.ReplaceConnectorPointsHistoryItem(connector.key, newPoints));
    };
    DataSource.prototype.compareTexts = function (edgeObj, connector) {
        var texts = edgeObj.texts || {};
        var result = Object.keys(texts).length === connector.getTextCount();
        if (result)
            for (var key in texts) {
                if (!Object.prototype.hasOwnProperty.call(texts, key))
                    continue;
                var position = parseFloat(key);
                if (!this.compareStrings(connector.getText(position), texts[key]))
                    result = false;
            }
        return result;
    };
    DataSource.prototype.compareStrings = function (str1, str2) {
        if (typeof str1 === "string" && typeof str2 === "string")
            return str1 === str2;
        return this.isEmptyString(str1) && this.isEmptyString(str2);
    };
    DataSource.prototype.isEmptyString = function (str) {
        return str === "" || str === null || str === undefined;
    };
    return DataSource;
}());
exports.DataSource = DataSource;
//# sourceMappingURL=DataSource.js.map